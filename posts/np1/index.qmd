---
title: "넘파이 배열(1차원:벡터, 2차원:행렬, 3차원:텐서)"
author: "Sol"
date: "2024-07-18"
categories: [numpy]
---
# 1. 벡터: 1차원 넘파이 배열
## 정의
- 벡터 : 숫자들의 일렬로 구성된 데이터 구조
- 넘파이 벡터: 1차원 넘파이 배열

## 특징
- 동일한 자료형 : 계산의 효율성을 높이기 위해
- 고속 연산 : 반복문을 사용하지 않고도 빠른 연산 수행
- 다양한 연산 지원: 벡터간의 덧셈, 뺄셈 등 수학적 연산 지원
- 메모리의 효율성: 파이썬 리스트보다 메모리를 적게 사용함

## 생성
### 생성(1) 빈 배열 생성 후 값 채워넣기: np.empty(), np.zeros()
```{python}
x = np.empty(3) # 쓰레기값으로 채워진 원소 3개짜리 1차원 배열
x
x[0] = 3
x[1] = 5
x[2] = 3
x
y = np.zeros(3) # 0으로 채워진 원소 3개짜리 1차원 배열
y
```


# 2. 행렬: 2차원 넘파이 배열
## 1차원 2개 합치기: np.vstack(np.array1,np.array2)
```{python}
import numpy as np

matrix = np.vstack((
    np.arange(1,5),
    np.arange(12,16)
))
matrix
```
## 0으로 이루어진 2차원 배열 만들기 : .zeros()
```{python}
np.zeros([5,4])
```
## 1차원 배열을 2차원 배열로 바꾸기: .reshape((행,열),order="C 또는 F")
```{python}
np.arange(1,7).reshape((2,3))
```
### .reshape 특징(1) -1을 통해서 크기를 자동으로 결정할 수 있음
```{python}
np.arange(1,7).reshape((2,-1))
```
```{python}
np.arange(1,7).reshape((-1,3))
```
### .reshape 특징(2) order="F"인자로 값의 순서를 정할 수 있음
1) order="C" : 행우선, 기본값이라 입력 안하면 자동으로 적용됨
2) order="F" : 열우선
```{python}
np.arange(1,7).reshape((-1,3),order="F")
```

## 2차원 배열의 인덱싱
```{python}
mat_a = np.arange(1,21).reshape((4,5),order="F")
mat_a
```
```{python}
mat_a[0,0]
mat_a[1,1]
mat_a[2,3]
mat_a[0:2,3]
mat_a[1:3,1:4]
mat_b = np.arange(1,101).reshape((20,-1))
mat_b[1::2,:]
mat_b[[1,4,6,14],]
```
## 참, 거짓 값과 인덱싱을 을 이용해 2차원 배열의 값 추출
```{python}
x = np.arange(1, 11).reshape((5, 2)) * 2
x
x[[True, True, False, False, True], 0]
```
## 필터링: 인덱싱에 조건식을 적용해 필터링
Q. 1 열의 값이 50보다 큰 행들만, 열은 모두 가져오기
```{python}
mat_b[mat_b[:,1]>50,:] 
```
## 넘파이 배열 메서드: .sum(), .mean(), .max(), .min(), cumsum(), cumprod()
```{python}
a = np.array([[1, 2, 3], [4, 5, 6]])
a
a.sum() # 모든 원소 합계
a.mean() # 모든 원소 평균
a.max() # 모든 원소 중 가장 큰 수
a.min() # 모든 원소 중 가장 작은 수
a.cumsum() # 모든 원소 누적합
a.cumprod() # 모든 원소 누적곱
```


## 행끼리, 열끼리 계산:  axis=1(행끼리), axis=0(열끼리)
```{python}
a = np.array([[1, 2, 3], [4, 5, 6]])
a
a.sum(axis=1) # 행별 합계
a.mean(axis=1) # 행별 평균
a.max(axis=1) # 행별 가장 큰 수
a.min(axis=1) # 행별 가장 작은 수
a.cumsum(axis=1) # 행별 누적합
a.cumprod(axis=1) # 행별 누적곱
```

# 3. 텐서: 3차원 배열 이상

## 다차원을 1차원으로: .flatten()
```{python}
a = np.array([[1, 2, 3], [4, 5, 6]])
a
a.flatten()
b=np.arange(1,101).reshape((5,5,4))
b.flatten()
```

