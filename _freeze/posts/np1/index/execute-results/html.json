{
  "hash": "84dfce52eee7e76d805306a235195f55",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"넘파이 배열\"\nauthor: \"Sol\"\ndate: \"2024-07-18\"\ncategories: [numpy]\n---\n\n# 1. 정의\n1. 0차원 배열: 스칼라, 단순한 하나의 숫자\n2. 1차원 배열: 벡터, 숫자들이 일렬로 구성된 데이터 구조\n3. 2차원 배열: 행렬\n4. 3차원 이상: 텐서\n\n# 2. 특징\n- 동일한 자료형 : 계산의 효율성을 높이기 위해\n- 고속 연산 : 반복문을 사용하지 않고도 빠른 연산 수행\n- 다양한 연산 지원: 벡터간의 덧셈, 뺄셈 등 수학적 연산 지원\n- 메모리의 효율성: 파이썬 리스트보다 메모리를 적게 사용함\n\n# 3. 생성\n## (1) .empty(): 쓰레기값이 들어간 빈 배열 \n\n::: {#0644cde1 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n?np.empty\nx = np.empty(3)\n# e^-10은 10^-10이다. 0으로 봐도 무방할 정도로 0에 가까운 수\nx[0] = 3\nx[1] = 5\nx[2] = 3\nx\n\ny = np.empty(3,dtype=int)\ny[0] = 3\ny[1] = 5\ny[2] = 3\ny\n\nz = np.empty([3,3], dtype=int)\nz\nnp.zeros(3) # 0으로 채워진 원소 3개짜리 1차원 배열\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\narray([0., 0., 0.])\n```\n:::\n:::\n\n\n## (2) .zeros() : 0으로 채워진 배열\n\n::: {#ab09bef8 .cell execution_count=2}\n``` {.python .cell-code}\nnp.zeros(3)\nnp.zeros([3,3])\nnp.zeros([2,2],dtype=int)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([[0, 0],\n       [0, 0]])\n```\n:::\n:::\n\n\n## (3) np.array() : 직접 값 입력\n\n::: {#1a9a8ce2 .cell execution_count=3}\n``` {.python .cell-code}\nnp.array([1,2,3])\nnp.array([1,2,3],dtype=float)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\narray([1., 2., 3.])\n```\n:::\n:::\n\n\n## (4) np.arange() : 일정 간격으로 숫자 생성하며 배열 생성\n\n::: {#f9ad3fb2 .cell execution_count=4}\n``` {.python .cell-code}\nnp.arange(10) # 0부터 9까지\nnp.arange(1,10,2,dtype=float) # 1부터 9까지 2씩 건너뛰며 생성\nnp.arange(0,2,0.5)\nnp.arange(0,2.1,0.5)\nnp.arange(0,-100,-1)\n-np.arange(100)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\narray([  0,  -1,  -2,  -3,  -4,  -5,  -6,  -7,  -8,  -9, -10, -11, -12,\n       -13, -14, -15, -16, -17, -18, -19, -20, -21, -22, -23, -24, -25,\n       -26, -27, -28, -29, -30, -31, -32, -33, -34, -35, -36, -37, -38,\n       -39, -40, -41, -42, -43, -44, -45, -46, -47, -48, -49, -50, -51,\n       -52, -53, -54, -55, -56, -57, -58, -59, -60, -61, -62, -63, -64,\n       -65, -66, -67, -68, -69, -70, -71, -72, -73, -74, -75, -76, -77,\n       -78, -79, -80, -81, -82, -83, -84, -85, -86, -87, -88, -89, -90,\n       -91, -92, -93, -94, -95, -96, -97, -98, -99])\n```\n:::\n:::\n\n\n## (5) np.linspace() : 균일 간격으로 배열 생성\n\n::: {#5475166c .cell execution_count=5}\n``` {.python .cell-code}\nnp.linspace(0,100,5) # 0부터 100까지 균일 간격으로 5개 반환\nnp.linspace(0,100,5,retstep=True) # 0부터 100까지 균일 간격 25도 함께 반환\nnp.linspace(0,100,5,retstep=True,dtype=int)\nnp.linspace(0,100,5,endpoint=False) # 100은 포함하지 않음\nnp.linspace(0,10) # 간격 기본값은 50이므로 1부터 10까지 균일간격으로 50개생성\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\narray([ 0.        ,  0.20408163,  0.40816327,  0.6122449 ,  0.81632653,\n        1.02040816,  1.2244898 ,  1.42857143,  1.63265306,  1.83673469,\n        2.04081633,  2.24489796,  2.44897959,  2.65306122,  2.85714286,\n        3.06122449,  3.26530612,  3.46938776,  3.67346939,  3.87755102,\n        4.08163265,  4.28571429,  4.48979592,  4.69387755,  4.89795918,\n        5.10204082,  5.30612245,  5.51020408,  5.71428571,  5.91836735,\n        6.12244898,  6.32653061,  6.53061224,  6.73469388,  6.93877551,\n        7.14285714,  7.34693878,  7.55102041,  7.75510204,  7.95918367,\n        8.16326531,  8.36734694,  8.57142857,  8.7755102 ,  8.97959184,\n        9.18367347,  9.3877551 ,  9.59183673,  9.79591837, 10.        ])\n```\n:::\n:::\n\n\n## (6) np.random.randint() : 랜덤값으로 생성\n\n::: {#5d807691 .cell execution_count=6}\n``` {.python .cell-code}\nnp.random.seed(4) # seed안의 값이 같으면 다른 사람과 같은 랜덤값을 얻을 수 있다\nnp.random.rand(5) # 0부터 1미만의 수 5개\nnp.random.rand(5,3) # 0부터 1미만의 수 5행 3열\nnp.random.randint(0,10,2) # 0부터 10미만의 수 2개\nnp.random.randint(2,5) # 2에서 5미만의 수 1개\nnp.random.randint(2,5,[2,2]) # 2에서 5미만의 수로 채워진 2행2열\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([[4, 2],\n       [2, 4]], dtype=int32)\n```\n:::\n:::\n\n\n# 4. 크기 확인하기: len() 길이, .shape 행열, .size 원소갯수\n\n::: {#40d3d55d .cell execution_count=7}\n``` {.python .cell-code}\na= np.array([[1, 2, 3], [4, 5, 6]])\nlen(a)\na.shape # 튜플로 (행,열) 반환\na.size\nb= np.array([1])\nb.shape\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n(1,)\n```\n:::\n:::\n\n\n# 5. 벡터 연산\n\n::: {#0af38aad .cell execution_count=8}\n``` {.python .cell-code}\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\na+b # 리스트는 두개가 합쳐짐 [1,2,3,4,5,6] \na-b # 리스트는 에러남\na*b # 리스트는 에러남 \na/b # 리스트는 에러남\na//b # 리스트는 에러남 \na%b # 리스트는 에러남\na*2 # 리스트는 2번 반복 [1,2,3,1,2,3]\na/2 # 리스트는 에러남\na+2 # 리스트는 에러남\na//b\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([0, 0, 0])\n```\n:::\n:::\n\n\n## 브로드캐스팅: 다른 차원의 배열들의 연산 가능\n### (1) 다차원과 0차원(스칼라)의 연산: 스칼라가 다차원인 것처럼 계산\n\n::: {#46b03bab .cell execution_count=9}\n``` {.python .cell-code}\na= np.array([1,2,3])\na*2\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\narray([2, 4, 6])\n```\n:::\n:::\n\n\n### (2) 다차원과 1차원의 연산: 행이 일치하거나 열이 일치하면 가능\n\n::: {#ea5cb946 .cell execution_count=10}\n``` {.python .cell-code}\na=np.array([[1,2,3],[4,5,6]])\na\nb=np.array([10,20,30])\nb\na*b # b가 [[10,20,30],[10,20,30]]인것처럼 계산\nc=np.array([[10],[20]])\nc\na*c # c가 [[10,10,10],[20,20,20]]인것처럼 계산\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\narray([[ 10,  20,  30],\n       [ 80, 100, 120]])\n```\n:::\n:::\n\n\n### 같은 차원의 경우 길이가 다르면 에러남\n\n::: {#e29b1738 .cell execution_count=11}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4])\nb = np.array([1, 2])\n# a+b 에러남\na+np.tile(b,2)\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\narray([2, 4, 4, 6])\n```\n:::\n:::\n\n\n### 배열 길이 맞추기 (1) np.resize() - 값을 앞에서부터 맞춰준다\n\n::: {#d03bd014 .cell execution_count=12}\n``` {.python .cell-code}\na = np.array([1, 2, 3, 4, 5, 6])\nb = np.array([7, 8, 9, 10])\nnp.resize(b,len(a))\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\narray([ 7,  8,  9, 10,  7,  8])\n```\n:::\n:::\n\n\n### 배열 길이 맞추기 (2) np.repeat() : 배열의 값을 반복\n\n::: {#a0ebce8d .cell execution_count=13}\n``` {.python .cell-code}\nnp.repeat(5,3) # 5가 3번 반복됨\nnp.repeat([1,2,3],3) # 1이 3번, 2가 3번, 3이 3번 반복됨\nnp.repeat([1,2,3],[2,1,4]) # 1이 2번, 2가 1번, 3이 4번 반복됨\nnp.array([[1,2,3],[4,5,6]])\nnp.repeat([[1,2,3],[4,5,6]],3) # 1차원으로 바뀜\nnp.repeat([[1,2,3],[4,5,6]],3,axis=1) # 각 열이 3번 반복됨\nnp.repeat([[1,2,3],[4,5,6]],3,axis=0) # 각 행이 3번 반복됨\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n```\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3],\n       [4, 5, 6],\n       [4, 5, 6],\n       [4, 5, 6]])\n```\n:::\n:::\n\n\n### 배열 길이 맞추기(3) np.tile() : 배열 자체를 반복\n\n::: {#00a2aa11 .cell execution_count=14}\n``` {.python .cell-code}\nnp.tile(5,3) # 5가 3번 반복됨\nnp.tile([1,2,3],3) # [1,2,3]이 3번 반복됨\nnp.tile([1,2,3],[3,2]) # [1,2,3]이 2번 반복된게 3행 생성\n```\n\n::: {.cell-output .cell-output-display execution_count=14}\n```\narray([[1, 2, 3, 1, 2, 3],\n       [1, 2, 3, 1, 2, 3],\n       [1, 2, 3, 1, 2, 3]])\n```\n:::\n:::\n\n\n# 6. 인덱스\n\n::: {#7199404f .cell execution_count=15}\n``` {.python .cell-code}\na=np.array([1,2,3,4,5,6,7,8])\na[0]\na[-1]\na[::2] # 2칸씩\nnp.delete(a,1) # 1번인덱스 빼고 가져와라\nnp.delete(a,[1,2,3]) # 1번,2번,3번 인덱스 빼고 가져와라\n# np.delete(a,[0:3])는 에러남\na[[1,3]] # 1번,3번 인덱스만 가져와라\na>3 # True, False값이 반환됨\na[a>3] # 원소값이 3보다 큰 값만 가져와라\na[(a<2) | (a>4)] # 값이 2보다 작거나 4보다 큰 값만 가져와라\nb = np.array([5, 10, 15, 20, 25, 30])\nb[b>=10] = 10 # b의 값이 10보다 크거나 같은 값에 10을 대입해라\nb\n```\n\n::: {.cell-output .cell-output-display execution_count=15}\n```\narray([ 5, 10, 10, 10, 10, 10])\n```\n:::\n:::\n\n\n# 7. 조건을 만족하는 위치 탐색 np.where()\n\n::: {#8299832d .cell execution_count=16}\n``` {.python .cell-code}\na = np.array([5, 10, 15, 20, 25, 30])\nnp.where(a>15) # 값이 15보다 큰 배열의 인덱스 반환\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```\n(array([3, 4, 5]),)\n```\n:::\n:::\n\n\n# 8. 데이터가 정의 되지 않은 경우: np.nan (not a number)\n1) np.nan은 float타입의 numpy에서 제공하는 상수이다.\n2) 데이터 분석에서 결측값(missing value)을 나타낼 때 주로 사용한다.\n3) 비교는 `==`연산자는 사용할 수 없고 np.isnan()을 사용해 확인한다.\n\n::: {#c4f8fb1a .cell execution_count=17}\n``` {.python .cell-code}\na = np.array([20, np.nan, 13, 24, 309])\na\na.mean() # nan\nnp.nanmean(a) # nan무시\nnp.isnan(a) # 각 값에 True, False 배열로 나타남\nnp.nan_to_num(a,nan=0) # nan이 있으면 0값으로 바꿔라\nnp.nan_to_num(a,nan=100) # nan이 있으면 0값으로 바꿔라\n~np.isnan(a) # nan이 아니면 True, 맞으면 False\na[~np.isnan(a)] # nan이 아닌 값만 가져와라\n```\n\n::: {.cell-output .cell-output-display execution_count=17}\n```\narray([ 20.,  13.,  24., 309.])\n```\n:::\n:::\n\n\n# 9. 값이 없는 경우: None\n\n::: {#03ec1834 .cell execution_count=18}\n``` {.python .cell-code}\na = np.array([20, None, 13, 24, 309])\na\n```\n\n::: {.cell-output .cell-output-display execution_count=18}\n```\narray([20, None, 13, 24, 309], dtype=object)\n```\n:::\n:::\n\n\n# 10. 벡터는 같은 타입끼리만 담긴다\n\n::: {#cfb44547 .cell execution_count=19}\n``` {.python .cell-code}\na= np.array([1,\"2\",3]) # 값을 모두 str 타입으로 바꿔줌\na[[1,2]] #1,2번 인덱스 값을 가져와라\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\narray(['2', '3'], dtype='<U21')\n```\n:::\n:::\n\n\n# 11. 벡터 합치기\n## (1) 하나로 합치기: np.concate()\n\n::: {#9c78bda5 .cell execution_count=20}\n``` {.python .cell-code}\na=np.array([1,2])\nb=np.array([4,5,6])\nnp.concatenate((a,b))\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\narray([1, 2, 4, 5, 6])\n```\n:::\n:::\n\n\n## (2) 열로 쌓기: np.column_stack() - 길이가 같아야 함\n\n::: {#cbda0361 .cell execution_count=21}\n``` {.python .cell-code}\na=np.array([1,2,3])\nb=np.array([4,5,6])\nnp.column_stack((a,b)) # 첫번째 배열을 0열에, 두번째 배열을 1열에\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n```\n:::\n:::\n\n\n## (3) 행으로 쌓기: np.vstack() - 길이가 같아야 함\n\n::: {#fe90557e .cell execution_count=22}\n``` {.python .cell-code}\na=np.array([1,2,3])\nb=np.array([4,5,6])\nnp.vstack((a,b)) # 첫번쨰 배열을 0행에, 두번쨰 배열을 0행에\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\narray([[1, 2, 3],\n       [4, 5, 6]])\n```\n:::\n:::\n\n\n# 12. 벡터 차원 바꾸기 : .reshape()\n\n::: {#757b925f .cell execution_count=23}\n``` {.python .cell-code}\nnp.arange(1,7).reshape((2,3))\n```\n\n::: {.cell-output .cell-output-display execution_count=23}\n```\narray([[1, 2, 3],\n       [4, 5, 6]])\n```\n:::\n:::\n\n\n## (1) -1을 통해서 크기를 자동으로 결정할 수 있음\n\n::: {#886ebcd2 .cell execution_count=24}\n``` {.python .cell-code}\nnp.arange(1,7).reshape((2,-1))\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\narray([[1, 2, 3],\n       [4, 5, 6]])\n```\n:::\n:::\n\n\n::: {#b298ea40 .cell execution_count=25}\n``` {.python .cell-code}\nnp.arange(1,7).reshape((-1,3))\n```\n\n::: {.cell-output .cell-output-display execution_count=25}\n```\narray([[1, 2, 3],\n       [4, 5, 6]])\n```\n:::\n:::\n\n\n## (2) order=\"F\"인자로 값의 순서를 정할 수 있음\n1) order=\"C\" : 행우선, 기본값이라 입력 안하면 자동으로 적용됨\n2) order=\"F\" : 열우선\n\n::: {#f249afcd .cell execution_count=26}\n``` {.python .cell-code}\nnp.arange(1,7).reshape((-1,3),order=\"F\")\n```\n\n::: {.cell-output .cell-output-display execution_count=26}\n```\narray([[1, 3, 5],\n       [2, 4, 6]])\n```\n:::\n:::\n\n\n# 13. 다차원을 1차원으로: .flatten()\n\n::: {#2c9f9d92 .cell execution_count=27}\n``` {.python .cell-code}\na = np.array([[1, 2, 3], [4, 5, 6]])\na\na.flatten()\nb=np.arange(1,101).reshape((5,5,4))\nb.flatten()\n```\n\n::: {.cell-output .cell-output-display execution_count=27}\n```\narray([  1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,\n        14,  15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,\n        27,  28,  29,  30,  31,  32,  33,  34,  35,  36,  37,  38,  39,\n        40,  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,\n        53,  54,  55,  56,  57,  58,  59,  60,  61,  62,  63,  64,  65,\n        66,  67,  68,  69,  70,  71,  72,  73,  74,  75,  76,  77,  78,\n        79,  80,  81,  82,  83,  84,  85,  86,  87,  88,  89,  90,  91,\n        92,  93,  94,  95,  96,  97,  98,  99, 100])\n```\n:::\n:::\n\n\n# 14. 다차원 배열의 인덱싱\n\n::: {#26fee7c8 .cell execution_count=28}\n``` {.python .cell-code}\nmat_a = np.arange(1,21).reshape((4,5),order=\"F\")\nmat_a\n```\n\n::: {.cell-output .cell-output-display execution_count=28}\n```\narray([[ 1,  5,  9, 13, 17],\n       [ 2,  6, 10, 14, 18],\n       [ 3,  7, 11, 15, 19],\n       [ 4,  8, 12, 16, 20]])\n```\n:::\n:::\n\n\n::: {#4bb5c023 .cell execution_count=29}\n``` {.python .cell-code}\nmat_a[0,0]\nmat_a[1,1]\nmat_a[2,3]\nmat_a[0:2,3]\nmat_a[1:3,1:4]\nmat_b = np.arange(1,101).reshape((20,-1))\nmat_b[1::2,:]\nmat_b[[1,4,6,14],]\n```\n\n::: {.cell-output .cell-output-display execution_count=29}\n```\narray([[ 6,  7,  8,  9, 10],\n       [21, 22, 23, 24, 25],\n       [31, 32, 33, 34, 35],\n       [71, 72, 73, 74, 75]])\n```\n:::\n:::\n\n\n## 참, 거짓 값과 인덱싱을 을 이용해 2차원 배열의 값 추출\n\n::: {#420d2762 .cell execution_count=30}\n``` {.python .cell-code}\nx = np.arange(1, 11).reshape((5, 2)) * 2\nx\nx[[True, True, False, False, True], 0]\n```\n\n::: {.cell-output .cell-output-display execution_count=30}\n```\narray([ 2,  6, 18])\n```\n:::\n:::\n\n\n## 필터링: 인덱싱에 조건식을 적용해 필터링\nQ. 1 열의 값이 50보다 큰 행들만, 열은 모두 가져오기\n\n::: {#7051f965 .cell execution_count=31}\n``` {.python .cell-code}\nmat_b[mat_b[:,1]>50,:] \n```\n\n::: {.cell-output .cell-output-display execution_count=31}\n```\narray([[ 51,  52,  53,  54,  55],\n       [ 56,  57,  58,  59,  60],\n       [ 61,  62,  63,  64,  65],\n       [ 66,  67,  68,  69,  70],\n       [ 71,  72,  73,  74,  75],\n       [ 76,  77,  78,  79,  80],\n       [ 81,  82,  83,  84,  85],\n       [ 86,  87,  88,  89,  90],\n       [ 91,  92,  93,  94,  95],\n       [ 96,  97,  98,  99, 100]])\n```\n:::\n:::\n\n\n# 15. 넘파이 배열 메서드: .sum(), .mean(), .max(), .min(), cumsum(), cumprod(), .argmax(), .argmin(), .clip(), .tolist(), astype(), .copy()\n\n::: {#bbd1313d .cell execution_count=32}\n``` {.python .cell-code}\na = np.array([[1, 2, 3], [4, 5, 6]])\na\na.sum() # 모든 원소 합계\na.mean() # 모든 원소 평균\na.max() # 모든 원소 중 가장 큰 수\na.min() # 모든 원소 중 가장 작은 수\na.cumsum() # 모든 원소 누적합\na.cumprod() # 모든 원소 누적곱\na.argmax() # 모든 원소 중 가장 큰 수의 인덱스\na.argmin() # 모든 원소 중 가장 작은 수의 인덱스\na.clip(2,4) # 2보다 작으면 2로, 4보다 크면 4로 반환\ntype(a) # numpy.ndarray\ntype(a.tolist()) # 넘파이배열을 list로 타입 변경\nb= np.array([1.1, 2.2, 3.3])\nb\nb.astype(int) # 원소의 타입 변경\n```\n\n::: {.cell-output .cell-output-display execution_count=32}\n```\narray([1, 2, 3])\n```\n:::\n:::\n\n\n## 행끼리, 열끼리 계산:  axis=1(행끼리), axis=0(열끼리)\n\n::: {#96b0e30a .cell execution_count=33}\n``` {.python .cell-code}\na = np.array([[1, 2, 3], [4, 5, 6]])\na\na.sum(axis=1) # 행별 합계\na.mean(axis=1) # 행별 평균\na.max(axis=1) # 행별 가장 큰 수\na.min(axis=1) # 행별 가장 작은 수\na.cumsum(axis=1) # 행별 누적합\na.cumprod(axis=1) # 행별 누적곱\nb = np.array([[4,2,1],[3,6,5]])\nb\nb.argmax(axis=1) # 행별 모든 원소 중 가장 큰 수의 인덱스\nb.argmin(axis=1) # 행별 모든 원소 중 가장 작은 수의 인덱스\nb.argmax(axis=0) # 열별 모든 원소 중 가장 큰 수의 인덱스\nb.argmin(axis=0) # 열별 모든 원소 중 가장 작은 수의 인덱스\n```\n\n::: {.cell-output .cell-output-display execution_count=33}\n```\narray([1, 0, 0])\n```\n:::\n:::\n\n\n# 16. 행,열 바꾸기: .transpose()\n\n::: {#c630c702 .cell execution_count=34}\n``` {.python .cell-code}\na=np.array([[1,2,3],[4,5,6]])\na\na.transpose()\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n```\n:::\n:::\n\n\n# 17. 행렬의 곱 : .dot()\n\n::: {#845be70b .cell execution_count=35}\n``` {.python .cell-code}\na=np.array([[1,2,3],[4,5,6]])\na\nb=np.array([[7,8],[9,10],[11,12]])\nb\na.dot(b)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\narray([[ 58,  64],\n       [139, 154]])\n```\n:::\n:::\n\n\n# 18. 행렬의 원소의 곱 : *\n\n::: {#bf18d8dd .cell execution_count=36}\n``` {.python .cell-code}\na=np.array([[1,2,3],[4,5,6]])\nb=np.array([[7,8,9],[10,11,12]])\na*b\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\narray([[ 7, 16, 27],\n       [40, 55, 72]])\n```\n:::\n:::\n\n\n# 19. 깊은 복사: .copy() 값만 복사\n\n::: {#9f89202d .cell execution_count=37}\n``` {.python .cell-code}\na = np.array([1,2,3,4,5])\na\nb = a # a의 주소값을 복사\nb\nc = a.copy() # 값을 복사\nc\na[0] = 100\na\nb\nc\n```\n\n::: {.cell-output .cell-output-display execution_count=37}\n```\narray([1, 2, 3, 4, 5])\n```\n:::\n:::\n\n\n# 20. 배열의 정렬 : .sort(), .argsort()\n\n::: {#ce2c216a .cell execution_count=38}\n``` {.python .cell-code}\na = np.array([3,5,2,4,1])\na\na.sort() # 원본을 수정\na\nb = np.array([3,5,2,4,1])\nb.argsort() # 정렬했을때의 인덱스를 반환(원본 수정X)\nb\nb[b.argsort()] # 정렬된 인덱스로 출력\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```\narray([1, 2, 3, 4, 5])\n```\n:::\n:::\n\n\n# 우리가 보는 표는 행렬의 형태이기 때문에 인덱싱과 필터링 스킬이 중요!!\n\n# 연습문제\n## 1. \n\n::: {#c7508b31 .cell execution_count=39}\n``` {.python .cell-code}\nA = np.array([[3,5,7],[2,3,6]])\nA\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```\narray([[3, 5, 7],\n       [2, 3, 6]])\n```\n:::\n:::\n\n\n## 2. \n\n::: {#c47c7a47 .cell execution_count=40}\n``` {.python .cell-code}\nB = np.array([[8,10,7,8],[2,4,5,5],[7,6,1,7],[2,6,8,6],[9,3,4,2]])\nB\nB[[1,3,4],:]\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```\narray([[2, 4, 5, 5],\n       [2, 6, 8, 6],\n       [9, 3, 4, 2]])\n```\n:::\n:::\n\n\n## 3.\n\n::: {#c993855b .cell execution_count=41}\n``` {.python .cell-code}\nB[B[:,2]>3,:]\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```\narray([[ 8, 10,  7,  8],\n       [ 2,  4,  5,  5],\n       [ 2,  6,  8,  6],\n       [ 9,  3,  4,  2]])\n```\n:::\n:::\n\n\n## 4.\n\n::: {#f98cef22 .cell execution_count=42}\n``` {.python .cell-code}\nrow_sums = np.sum(B, axis =1)\nprint(\"각 행별 합계:\\n\", row_sums)\nB[row_sums>=20,:]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n각 행별 합계:\n [33 16 21 22 18]\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=42}\n```\narray([[ 8, 10,  7,  8],\n       [ 7,  6,  1,  7],\n       [ 2,  6,  8,  6]])\n```\n:::\n:::\n\n\n## 5. \n\n::: {#e9618c4d .cell execution_count=43}\n``` {.python .cell-code}\nB\nB.mean(axis=0)\nnp.where(B.mean(axis=0)>5)[0]\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```\narray([0, 1, 3])\n```\n:::\n:::\n\n\n## 6. \n\n::: {#1815ce62 .cell execution_count=44}\n``` {.python .cell-code}\nnp.sum(B >=5)\nnp.sum(B>7, axis=1)\nB[np.sum(B>7, axis=1)>0,:]\n```\n\n::: {.cell-output .cell-output-display execution_count=44}\n```\narray([[ 8, 10,  7,  8],\n       [ 2,  6,  8,  6],\n       [ 9,  3,  4,  2]])\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}